//! Rust-to-JavaScript Code Generation Utilities
//!
//! This crate provides utilities for generating JavaScript code from Rust constants
//! at build time, ensuring a single source of truth for shared values.
//!
//! # Examples
//!
//! ```
//! use rust_js_sync_codegen::{JsCodegen, JsValue};
//!
//! let mut codegen = JsCodegen::new();
//! codegen.add_const("IGNORED_CODES", JsValue::Array(vec![
//!     JsValue::Number(2307),
//!     JsValue::Number(2304),
//! ]));
//!
//! let js_code = codegen.generate();
//! ```

use std::fmt;

/// Represents a JavaScript value that can be code-generated
#[derive(Debug, Clone)]
pub enum JsValue {
    /// A number literal
    Number(i64),
    /// A string literal (will be properly escaped)
    String(String),
    /// A boolean literal
    Boolean(bool),
    /// An array of values
    Array(Vec<JsValue>),
    /// An object with key-value pairs
    Object(Vec<(String, JsValue)>),
    /// Null
    Null,
}

impl fmt::Display for JsValue {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            JsValue::Number(n) => write!(f, "{n}"),
            JsValue::String(s) => {
                // Escape special characters
                let escaped = s
                    .replace('\\', "\\\\")
                    .replace('"', "\\\"")
                    .replace('\n', "\\n")
                    .replace('\r', "\\r")
                    .replace('\t', "\\t");
                write!(f, "\"{escaped}\"")
            }
            JsValue::Boolean(b) => write!(f, "{b}"),
            JsValue::Array(items) => {
                write!(f, "[")?;
                for (i, item) in items.iter().enumerate() {
                    if i > 0 {
                        write!(f, ", ")?;
                    }
                    write!(f, "{item}")?;
                }
                write!(f, "]")
            }
            JsValue::Object(pairs) => {
                writeln!(f, "{{")?;
                for (i, (key, value)) in pairs.iter().enumerate() {
                    if i > 0 {
                        writeln!(f, ",")?;
                    }
                    write!(f, "  {key}: {value}")?;
                }
                write!(f, "\n}}")
            }
            JsValue::Null => write!(f, "null"),
        }
    }
}

/// JavaScript code generator
pub struct JsCodegen {
    constants: Vec<(String, JsValue, bool)>, // (name, value, is_exported)
}

impl JsCodegen {
    /// Create a new JavaScript code generator
    pub fn new() -> Self {
        Self {
            constants: Vec::new(),
        }
    }

    /// Add a constant to be generated
    pub fn add_const(&mut self, name: impl Into<String>, value: JsValue) -> &mut Self {
        self.constants.push((name.into(), value, false));
        self
    }

    /// Add an exported constant to be generated
    pub fn add_export(&mut self, name: impl Into<String>, value: JsValue) -> &mut Self {
        self.constants.push((name.into(), value, true));
        self
    }

    /// Generate the JavaScript code
    pub fn generate(&self) -> String {
        let mut output = String::new();

        output.push_str("// AUTO-GENERATED CODE - DO NOT EDIT\n");
        output.push_str("// This file was generated by rust_js_sync_codegen\n\n");

        for (name, value, is_exported) in &self.constants {
            if *is_exported {
                #[allow(clippy::format_push_string)]
                output.push_str(&format!("export const {name} = {value};\n"));
            } else {
                #[allow(clippy::format_push_string)]
                output.push_str(&format!("const {name} = {value};\n"));
            }
        }

        output
    }

    /// Generate and write to a file
    #[allow(clippy::missing_errors_doc)]
    pub fn write_to_file(&self, path: impl AsRef<std::path::Path>) -> std::io::Result<()> {
        std::fs::write(path, self.generate())
    }
}

impl Default for JsCodegen {
    fn default() -> Self {
        Self::new()
    }
}

/// Helper function to convert a slice of numbers to a `JsValue` array
pub fn numbers_to_js_array<T: Into<i64> + Copy>(numbers: &[T]) -> JsValue {
    JsValue::Array(numbers.iter().map(|&n| JsValue::Number(n.into())).collect())
}

/// Helper function to convert a slice of strings to a `JsValue` array
pub fn strings_to_js_array(strings: &[&str]) -> JsValue {
    JsValue::Array(
        strings
            .iter()
            .map(|&s| JsValue::String(s.to_string()))
            .collect(),
    )
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_number_value() {
        let val = JsValue::Number(42);
        assert_eq!(val.to_string(), "42");
    }

    #[test]
    fn test_string_value() {
        let val = JsValue::String("hello".to_string());
        assert_eq!(val.to_string(), "\"hello\"");
    }

    #[test]
    fn test_string_escaping() {
        let val = JsValue::String("hello\n\"world\"".to_string());
        assert_eq!(val.to_string(), "\"hello\\n\\\"world\\\"\"");
    }

    #[test]
    fn test_array_value() {
        let val = JsValue::Array(vec![
            JsValue::Number(1),
            JsValue::Number(2),
            JsValue::Number(3),
        ]);
        assert_eq!(val.to_string(), "[1, 2, 3]");
    }

    #[test]
    fn test_codegen_const() {
        let mut codegen = JsCodegen::new();
        codegen.add_const("MY_CONST", JsValue::Number(42));

        let output = codegen.generate();
        assert!(output.contains("const MY_CONST = 42;"));
        assert!(output.contains("AUTO-GENERATED"));
    }

    #[test]
    fn test_codegen_export() {
        let mut codegen = JsCodegen::new();
        codegen.add_export(
            "MY_EXPORT",
            JsValue::Array(vec![JsValue::Number(1), JsValue::Number(2)]),
        );

        let output = codegen.generate();
        assert!(output.contains("export const MY_EXPORT = [1, 2];"));
    }

    #[test]
    fn test_numbers_to_js_array() {
        let numbers = [1u32, 2, 3, 4];
        let val = numbers_to_js_array(&numbers);
        assert_eq!(val.to_string(), "[1, 2, 3, 4]");
    }
}
